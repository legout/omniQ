{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OmniQ: A Flexible Task Queue Library for Python","text":"<p>OmniQ is a modular Python task queue library designed for both local and distributed task processing. It provides a flexible architecture that supports multiple storage backends, worker types, and configuration methods. OmniQ enables developers to easily implement task queuing, scheduling, and distributed processing in their applications with both synchronous and asynchronous interfaces.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Multiple Storage Backends: Supports File, Memory, SQLite, PostgreSQL, Redis, and NATS.</li> <li>Multiple Worker Types: Includes Async, Thread Pool, Process Pool, and Gevent workers.</li> <li>Sync and Async Interfaces: Provides both synchronous and asynchronous APIs.</li> <li>Advanced Task Scheduling: Cron and interval patterns with pause/resume capabilities.</li> <li>Task Dependencies: Manage complex workflows.</li> <li>Event Logging: In-depth task lifecycle event logging.</li> <li>Flexible Configuration: Configure via code, objects, YAML, or environment variables.</li> <li>Cloud Storage: <code>fsspec</code> integration for cloud storage (S3, Azure, GCP).</li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<p>To get started with OmniQ, check out the Quickstart Guide.</p>"},{"location":"advanced/","title":"Advanced Usage","text":"<p>OmniQ is designed with flexibility in mind, offering advanced configuration options and features to handle complex, real-world scenarios. This guide covers some of the more sophisticated capabilities, including advanced configuration, handling mixed synchronous and asynchronous tasks, and integrating with cloud storage solutions.</p>"},{"location":"advanced/#configuration-based-setup","title":"Configuration-Based Setup","text":"<p>While you can instantiate OmniQ components directly, a configuration-driven approach offers greater flexibility, especially in production environments. This allows you to define your setup in YAML files, dictionaries, or even environment variables, decoupling your application logic from your infrastructure setup.</p>"},{"location":"advanced/#using-a-yaml-configuration-file","title":"Using a YAML Configuration File","text":"<p>For maximum clarity and maintainability, we recommend using a YAML file to define your OmniQ setup. This approach allows you to specify the project name, task queue, result store, and worker settings in a single, easy-to-read file.</p> <p>Here's an example of a <code>config.yaml</code> file:</p> <pre><code>project_name: production_app\n\ntask_queue:\n  type: file\n  config:\n    base_dir: ./omniq_data/tasks\n    queues:\n      - high_priority\n      - default\n      - low_priority\n\nresult_store:\n  type: sqlite\n  config:\n    base_dir: ./omniq_data/results\n\nworker:\n  type: thread_pool\n  config:\n    max_workers: 10\n</code></pre> <p>You can then load this configuration and create an <code>OmniQ</code> instance with a single command:</p> <pre><code>from omniq import OmniQ\n\n# Load the configuration from the YAML file\noq = OmniQ.from_config_file(\"config.yaml\")\n\n# Now your OmniQ instance is ready to use\nwith oq:\n    # Enqueue tasks, manage workers, etc.\n    pass\n</code></pre>"},{"location":"advanced/#using-environment-variables","title":"Using Environment Variables","text":"<p>For cloud-native applications and CI/CD pipelines, you can override configuration settings using environment variables. OmniQ recognizes variables prefixed with <code>OMNIQ_</code>.</p> <p>For example, to override the worker's <code>max_workers</code> setting, you can set the following environment variable:</p> <pre><code>export OMNIQ_WORKER_CONFIG_MAX_WORKERS=20\n</code></pre> <p>For more details on configuration loading and precedence, see the API reference under Configuration.</p>"},{"location":"advanced/#handling-sync-and-async-tasks","title":"Handling Sync and Async Tasks","text":"<p>Modern applications often require a mix of synchronous (CPU-bound) and asynchronous (I/O-bound) tasks. OmniQ's workers are designed to handle both types of tasks seamlessly within the same queue, simplifying your architecture.</p> <p>Both <code>ThreadWorker</code> and <code>AsyncWorker</code> can execute sync and async functions without any special configuration. The worker automatically detects whether a task function is a coroutine and executes it accordingly.</p> <pre><code>import asyncio\nimport time\nfrom omniq import OmniQ\nfrom omniq.queue import FileTaskQueue\n\n# A standard synchronous function\ndef sync_task(x, y):\n    print(f\"Executing sync task: {x} * {y}\")\n    time.sleep(0.1)\n    return x * y\n\n# An asynchronous function\nasync def async_task(x, y):\n    print(f\"Executing async task: {x} + {y}\")\n    await asyncio.sleep(0.1)\n    return x + y\n\n# Setup OmniQ (can be done via config file as well)\noq = OmniQ(project_name=\"mixed_tasks_example\")\n\nwith oq:\n    # Enqueue both types of tasks\n    sync_task_id = oq.enqueue(sync_task, func_args={'x': 5, 'y': 10})\n    async_task_id = oq.enqueue(async_task, func_args={'x': 5, 'y': 10})\n\n    # Wait for results\n    time.sleep(1)\n\n    # Retrieve results - the worker handles both correctly\n    sync_result = oq.get_result(sync_task_id)    # -&gt; 50\n    async_result = oq.get_result(async_task_id) # -&gt; 15\n\n    print(f\"Sync Result: {sync_result}\")\n    print(f\"Async Result: {async_result}\")\n</code></pre>"},{"location":"advanced/#cloud-storage-with-fsspec","title":"Cloud Storage with <code>fsspec</code>","text":"<p>OmniQ's <code>FileTaskQueue</code> and <code>FileResultStorage</code> components are built on top of the <code>fsspec</code> (Filesystem Spec) library. This powerful abstraction allows you to use virtually any storage backend that <code>fsspec</code> supports, including cloud storage providers like Amazon S3, Google Cloud Storage (GCS), and Azure Blob Storage.</p> <p>To use a cloud storage backend, simply provide the appropriate URI in the <code>base_dir</code> and include any necessary credentials in the <code>storage_options</code> dictionary.</p>"},{"location":"advanced/#example-using-amazon-s3","title":"Example: Using Amazon S3","text":"<p>First, ensure you have the required library installed:</p> <pre><code>pip install s3fs\n</code></pre> <p>Then, configure the <code>FileTaskQueue</code> to use an S3 bucket:</p> <pre><code>from omniq.queue import FileTaskQueue\n\n# Configuration for S3 storage\ns3_queue = FileTaskQueue(\n    project_name=\"s3_demo\",\n    base_dir=\"s3://your-cool-bucket/omniq/tasks\",\n    storage_options={\n        \"key\": \"YOUR_AWS_ACCESS_KEY_ID\",\n        \"secret\": \"YOUR_AWS_SECRET_ACCESS_KEY\",\n    }\n)\n\n# You can now use this queue with your OmniQ instance\n# oq = OmniQ(project_name=\"s3_demo\", task_queue=s3_queue, ...)\n</code></pre> <p>The same principle applies to <code>FileResultStorage</code> and other cloud providers like GCS (<code>gs://...</code>) and Azure Blob Storage (<code>abfs://...</code>).</p>"},{"location":"advanced/#performance-tips","title":"Performance Tips","text":"<ul> <li>Choose the Right Worker: Use <code>ThreadWorker</code> for I/O-bound synchronous tasks. For <code>async</code> tasks, <code>AsyncWorker</code> is generally more efficient as it can handle thousands of concurrent operations with a small number of threads.</li> <li>Serialization: The default serializer (<code>dill</code>) is very flexible but may not be the fastest. For performance-critical applications with well-defined data structures, consider using a faster serializer like <code>msgspec</code>.</li> <li>Batching: When enqueuing a large number of tasks, consider using <code>enqueue_many</code> to reduce the overhead of individual network requests or disk I/O operations.</li> <li>Persistent Connections: When using network-based backends (like Redis or a database), ensure your application manages connections efficiently. OmniQ's built-in components handle this, but be mindful if you create custom components.</li> </ul>"},{"location":"contributing/","title":"Contributing to OmniQ","text":"<p>We welcome contributions to OmniQ! Whether you're reporting an issue, submitting a feature request, or contributing code, your help is appreciated.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you encounter a bug or have a feature request, please submit an issue on our GitHub repository. When reporting a bug, please include:</p> <ul> <li>A clear and descriptive title.</li> <li>A detailed description of the issue, including steps to reproduce it.</li> <li>The version of OmniQ and Python you are using.</li> <li>Any relevant code snippets or error messages.</li> </ul>"},{"location":"contributing/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<p>We are happy to accept pull requests. Please follow these steps to contribute code:</p> <ol> <li>Fork the repository and create a new branch for your changes.</li> <li>Set up a development environment. We recommend using a virtual environment:</li> </ol> <pre><code># Create a virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows, use `.venv\\Scripts\\activate`\n\n# Install dependencies\npip install -e \".[dev]\"\n</code></pre> <ol> <li>Make your changes. Ensure your code follows the existing style and includes tests for any new functionality.</li> <li>Run the tests to ensure everything is working correctly:</li> </ol> <pre><code>pytest\n</code></pre> <ol> <li>Submit a pull request with a clear description of your changes and why they are needed.</li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use <code>black</code> for code formatting and <code>ruff</code> for linting. Please ensure your code conforms to these standards before submitting a pull request.</p> <p>Thank you for contributing to OmniQ!</p>"},{"location":"examples/","title":"Examples","text":"<p>This section will provide a variety of examples to demonstrate OmniQ's features.</p>"},{"location":"examples/#component-based-usage","title":"Component-Based Usage","text":"<pre><code>from omniq.queue import FileTaskQueue\nfrom omniq.storage import SQLiteResultStorage\nfrom omniq.workers import ThreadPoolWorker\nimport datetime as dt\n\n# Create components individually\nqueue = FileTaskQueue(\n    project_name=\"my_project\",\n    base_dir=\"some/path\",\n    queues=[\"low\", \"medium\", \"high\"]\n)\n\nresult_store = SQLiteResultStorage(\n    project_name=\"my_project\",\n    base_dir=\"some/path\"\n)\n\n# Create worker with reference to queue and result store\nworker = ThreadPoolWorker(\n    queue=queue,\n    result_store=result_store,\n    max_workers=20\n)\n\n# Define a task\ndef simple_task(name):\n    print(f\"Hello {name}\")\n    return name\n\n# Start the worker\nworker.start()\n\n# Enqueue a task\ntask_id = queue.enqueue(\n    func=simple_task,\n    func_args=dict(name=\"Tom\"),\n    queue_name=\"low\"\n)\n\n# Get the result\nresult = result_store.get(task_id)\n\n# Stop the worker\nworker.stop()\n\n# Using context managers\nwith FileTaskQueue(...) as queue, SQLiteResultStorage(...) as result_store, ThreadPoolWorker(queue=queue, result_store=result_store) as worker:\n    task_id = queue.enqueue(simple_task, func_args=dict(name=\"Tom\"))\n    result = result_store.get(task_id)\n</code></pre>"},{"location":"examples/#configuration-based-usage","title":"Configuration-Based Usage","text":"<pre><code>from omniq import OmniQ\nfrom omniq.models import FileTaskQueueConfig, SQLiteResultStorageConfig\n\n# Create components using specific config classes\nfrom omniq.queue import FileTaskQueue\nfrom omniq.storage import SQLiteResultStorage\n\nqueue = FileTaskQueue.from_config(\n    FileTaskQueueConfig(\n        project_name=\"my_project\",\n        base_dir=\"some/path\",\n        queues=[\"high\", \"medium\", \"low\"]\n    )\n)\n\nresult_store = SQLiteResultStorage.from_config(\n    SQLiteResultStorageConfig(\n        project_name=\"my_project\",\n        base_dir=\"some/path\"\n    )\n)\n\n# Load from YAML file\noq = OmniQ.from_config_file(\"config.yaml\")\n</code></pre>"},{"location":"examples/#working-with-multiple-queues","title":"Working with Multiple Queues","text":"<pre><code>from omniq.queue import PostgresTaskQueue\nfrom omniq.workers import ThreadPoolWorker\n\n# Create PostgreSQL queue with multiple named queues\nqueue = PostgresTaskQueue(\n    project_name=\"my_project\",\n    host=\"localhost\",\n    port=5432,\n    username=\"postgres\",\n    password=\"secret\",\n    queues=[\"high\", \"medium\", \"low\"]\n)\n\n# Create worker that processes queues in priority order\nworker = ThreadPoolWorker(queue=queue, max_workers=10)\nworker.start()\n\n# Enqueue tasks to different queues\nhigh_task_id = queue.enqueue(simple_task, func_args=dict(name=\"High Priority\"), queue_name=\"high\")\nmedium_task_id = queue.enqueue(simple_task, func_args=dict(name=\"Medium Priority\"), queue_name=\"medium\")\nlow_task_id = queue.enqueue(simple_task, func_args=dict(name=\"Low Priority\"), queue_name=\"low\")\n\n# Worker will process \"high\" queue tasks first, then \"medium\", then \"low\"\n</code></pre>"},{"location":"examples/#handling-both-sync-and-async-tasks","title":"Handling Both Sync and Async Tasks","text":"<pre><code>from omniq import OmniQ\nfrom omniq.queue import FileTaskQueue\nfrom omniq.workers import AsyncWorker\nimport asyncio\n\n# Create components\nqueue = FileTaskQueue(project_name=\"my_project\", base_dir=\"some/path\")\nworker = AsyncWorker(queue=queue, max_workers=10)\n\n# Define sync and async tasks\ndef sync_task(x, y):\n    return x * y\n\nasync def async_task(x, y):\n    await asyncio.sleep(0.1)  # Simulate I/O\n    return x + y\n\n# Start worker\nworker.start()\n\n# Enqueue both types of tasks\nsync_task_id = queue.enqueue(sync_task, func_args=dict(x=5, y=10))\nasync_task_id = queue.enqueue(async_task, func_args=dict(x=5, y=10))\n\n# Get results\nsync_result = worker.get_result(sync_task_id)  # 50\nasync_result = worker.get_result(async_task_id)  # 15\n</code></pre>"},{"location":"examples/#using-fsspec-for-cloud-storage","title":"Using fsspec for Cloud Storage","text":"<p>```python from omniq import OmniQ from omniq.queue import FileTaskQueue from omniq.storage import FileResultStorage</p>"},{"location":"examples/#using-local-filesystem-with-dirfilesystem","title":"Using local filesystem with DirFileSystem","text":"<p>local_queue = FileTaskQueue(     project_name=\"my_project\",     base_dir=\"/path/to/local/storage\",     queues=[\"high\", \"medium\", \"low\"] )</p>"},{"location":"examples/#using-s3-requires-s3fs-package","title":"Using S3 (requires s3fs package)","text":"<p>s3_queue = FileTaskQueue(     project_name=\"my_project\",     base_dir=\"s3://my-bucket/omniq\",     queues=[\"high\", \"medium\", \"low\"],     storage_options={\"key\": \"access_key\", \"secret\": \"secret_key\"} )</p>"},{"location":"examples/#create-omniq-with-cloud-storage","title":"Create OmniQ with cloud storage","text":"<p>oq = OmniQ(     project_name=\"my_project\",     task_queue=s3_queue,     result_store=FileResultStorage(base_dir=\"s3://my-bucket/omniq/results\") )</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This page will guide you through the process of setting up and using OmniQ.</p>"},{"location":"getting_started/#basic-usage-with-asyncomniq","title":"Basic Usage with AsyncOmniQ","text":"<pre><code>from omniq import AsyncOmniQ\nfrom omniq.queue import FileTaskQueue\nfrom omniq.storage import SQLiteResultStorage, PostgresEventStorage\nimport datetime as dt\n\n# Create AsyncOmniQ instance with default components\noq = AsyncOmniQ(\n    project_name=\"my_project\",\n    task_queue=FileTaskQueue(base_dir=\"some/path\", queues=[\"low\", \"medium\", \"high\"]),\n    result_store=SQLiteResultStorage(base_dir=\"some/path\"),\n    event_store=PostgresEventStorage(host=\"localhost\", port=5432, username=\"postgres\")\n)\n\n# Define an async task\nasync def async_task(name):\n    print(f\"Hello {name}\")\n    return name\n\n# Start the worker\nawait oq.start_worker()\n\n# Enqueue a task\ntask_id = await oq.enqueue(\n    func=async_task,\n    func_args=dict(name=\"Tom\"),\n    queue_name=\"low\",\n    run_in=dt.timedelta(seconds=100),\n    ttl=dt.timedelta(hours=1),\n    result_ttl=dt.timedelta(minutes=5)\n)\n\n# Get the result\nresult = await oq.get_result(task_id)\n\n# Schedule a recurring task\nschedule_id = await oq.schedule(\n    func=async_task,\n    func_args=dict(name=\"Tom\"),\n    interval=dt.timedelta(seconds=10),\n    queue_name=\"low\"\n)\n\n# Get latest result from scheduled task\nlatest_result = await oq.get_result(schedule_id=schedule_id, kind=\"latest\")\n\n# Stop the worker\nawait oq.stop_worker()\n\n# Using async context manager\nasync with AsyncOmniQ(...) as oq:\n    task_id = await oq.enqueue(async_task, func_args=dict(name=\"Tom\"))\n    result = await oq.get_result(task_id)\n</code></pre>"},{"location":"getting_started/#basic-usage-with-omniq-sync","title":"Basic Usage with OmniQ (Sync)","text":"<p>```python from omniq import OmniQ from omniq.queue import FileTaskQueue from omniq.storage import SQLiteResultStorage, PostgresEventStorage import datetime as dt</p>"},{"location":"getting_started/#create-omniq-instance-with-default-components","title":"Create OmniQ instance with default components","text":"<p>oq = OmniQ(     project_name=\"my_project\",     task_queue=FileTaskQueue(base_dir=\"some/path\", queues=[\"low\", \"medium\", \"high\"]),     result_store=SQLiteResultStorage(base_dir=\"some/path\"),     event_store=PostgresEventStorage(host=\"localhost\", port=5432, username=\"postgres\") )</p>"},{"location":"getting_started/#define-a-task","title":"Define a task","text":"<p>def simple_task(name):     print(f\"Hello {name}\")     return name</p>"},{"location":"getting_started/#start-the-worker","title":"Start the worker","text":"<p>oq.start_worker()</p>"},{"location":"getting_started/#enqueue-a-task","title":"Enqueue a task","text":"<p>task_id = oq.enqueue(     func=simple_task,     func_args=dict(name=\"Tom\"),     queue_name=\"low\",     run_in=dt.timedelta(seconds=100),     ttl=dt.timedelta(hours=1),     result_ttl=dt.timedelta(minutes=5) )</p>"},{"location":"getting_started/#get-the-result","title":"Get the result","text":"<p>result = oq.get_result(task_id)</p>"},{"location":"getting_started/#schedule-a-recurring-task","title":"Schedule a recurring task","text":"<p>schedule_id = oq.schedule(     func=simple_task,     func_args=dict(name=\"Tom\"),     interval=dt.timedelta(seconds=10),     queue_name=\"low\" )</p>"},{"location":"getting_started/#get-latest-result-from-scheduled-task","title":"Get latest result from scheduled task","text":"<p>latest_result = oq.get_result(schedule_id=schedule_id, kind=\"latest\")</p>"},{"location":"getting_started/#stop-the-worker","title":"Stop the worker","text":"<p>oq.stop_worker()</p>"},{"location":"getting_started/#using-sync-context-manager","title":"Using sync context manager","text":"<p>with OmniQ(...) as oq:     task_id = oq.enqueue(simple_task, func_args=dict(name=\"Tom\"))     result = oq.get_result(task_id)</p>"},{"location":"installation/","title":"Installation","text":"<p>This guide provides instructions on how to install <code>omniq</code>.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before you install <code>omniq</code>, please ensure you have the following prerequisites met:</p> <ul> <li>Python: <code>omniq</code> requires Python 3.13 or higher. You can check your Python version by running:</li> </ul> <pre><code>python --version\n</code></pre>"},{"location":"installation/#installation-with-pip","title":"Installation with pip","text":"<p>You can install <code>omniq</code> directly from the Python Package Index (PyPI) using <code>pip</code>:</p> <pre><code>pip install omniq\n</code></pre> <p>We recommend installing <code>omniq</code> in a virtual environment to avoid conflicts with other packages.</p>"},{"location":"installation/#using-a-virtual-environment","title":"Using a Virtual Environment","text":"<ol> <li>Create a virtual environment:</li> </ol> <pre><code>python -m venv .venv\n</code></pre> <ol> <li>Activate the virtual environment:</li> <li>On macOS and Linux:</li> </ol> <pre><code>source .venv/bin/activate\n</code></pre> <ul> <li>On Windows:</li> </ul> <pre><code>.venv\\Scripts\\activate\n</code></pre> <ol> <li>Install <code>omniq</code>:</li> </ol> <pre><code>pip install omniq\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>Here are some common issues you might encounter during installation and how to resolve them.</p>"},{"location":"installation/#pip-not-found","title":"<code>pip</code> not found","text":"<p>If you get an error like <code>command not found: pip</code>, it means <code>pip</code> is not in your system's PATH. You can try using <code>python -m pip</code> instead:</p> <pre><code>python -m pip install omniq\n</code></pre>"},{"location":"installation/#old-version-of-pip","title":"Old version of <code>pip</code>","text":"<p>An outdated version of <code>pip</code> might cause issues. You can upgrade <code>pip</code> using the following command:</p> <pre><code>python -m pip install --upgrade pip\n</code></pre>"},{"location":"installation/#permission-errors","title":"Permission Errors","text":"<p>If you encounter permission errors during installation, you might be trying to install the package globally without sufficient privileges. Using a virtual environment, as described above, is the recommended way to avoid this. Alternatively, you can use the <code>--user</code> flag to install the package for your user only:</p> <p>```bash pip install --user omniq</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide provides a basic introduction to using <code>omniq</code> for task queuing. We'll walk through a simple synchronous example to get you started.</p>"},{"location":"quickstart/#basic-setup","title":"Basic Setup","text":"<p>First, let's define a simple function that we want to run as a background task.</p> <pre><code>import os\nfrom omniq import OmniQ\nfrom omniq.queue import FileTaskQueue\nfrom omniq.storage import SQLiteResultStorage, SQLiteEventStorage\n\n# Define a simple task function\ndef simple_task(name: str):\n    \"\"\"A simple task that prints a greeting and returns the name.\"\"\"\n    print(f\"Hello {name}\")\n    return name\n\n# Create directories for storage if they don't exist\nos.makedirs(\"task_queue\", exist_ok=True)\nos.makedirs(\"results\", exist_ok=True)\nos.makedirs(\"events\", exist_ok=True)\n</code></pre>"},{"location":"quickstart/#initializing-omniq","title":"Initializing OmniQ","text":"<p>Next, we'll create an instance of <code>OmniQ</code>. For this example, we'll use file-based and SQLite storage, which are easy to set up.</p> <pre><code># Create an OmniQ instance\noq = OmniQ(\n    project_name=\"quickstart_project\",\n    task_queue=FileTaskQueue(base_dir=\"task_queue\", queues=[\"default\"]),\n    result_store=SQLiteResultStorage(base_dir=\"results\"),\n    event_store=SQLiteEventStorage(base_dir=\"events\")\n)\n</code></pre>"},{"location":"quickstart/#enqueuing-and-retrieving-a-task","title":"Enqueuing and Retrieving a Task","text":"<p>Now we can enqueue our <code>simple_task</code> and then retrieve its result. We'll use a context manager (<code>with oq.worker():</code>) to ensure the worker starts up, processes the task, and then shuts down cleanly.</p> <pre><code># Start a worker, enqueue a task, and get the result\nwith oq.worker():\n    # Enqueue the task\n    task = oq.enqueue(simple_task, func_args=dict(name=\"World\"))\n    print(f\"Enqueued task with ID: {task.id}\")\n\n    # Retrieve the result\n    result = oq.get_result(task.id)\n    print(f\"Task result: {result.result}\")\n\nassert result.result == \"World\"\n</code></pre> <p>This example covers the basic workflow: 1. Define a task. 2. Initialize <code>OmniQ</code> with a queue and storage backends. 3. Start a worker. 4. Enqueue the task. 5. Retrieve the result.</p> <p>You can now explore more advanced features like scheduled tasks, asynchronous operations, and different storage backends.</p>"},{"location":"api/backends/","title":"Backends","text":"<p>This section will describe the different backends and their usage.</p> <p>The Backend classes provide a unified interface for storage systems. They allow you to create a task queue, result storage, and event storage from a single backend configuration.</p>"},{"location":"api/backends/#backend-based-usage","title":"Backend-Based Usage","text":"<p>```python from omniq import OmniQ from omniq.backend import SQLiteBackend, FileBackend, PostgresBackend</p>"},{"location":"api/backends/#create-backends","title":"Create backends","text":"<p>sqlite_backend = SQLiteBackend(project_name=\"my_project\", base_dir=\"some/path\") file_backend = FileBackend(project_name=\"my_project\", base_dir=\"some/path\") pg_backend = PostgresBackend(     project_name=\"my_project\",     host=\"localhost\",     port=5432,     username=\"postgres\",     password=\"secret\" )</p>"},{"location":"api/backends/#create-omniq-with-a-single-backend","title":"Create OmniQ with a single backend","text":"<p>oq = OmniQ.from_backend(sqlite_backend, worker_type=\"thread_pool\", worker_config={\"max_workers\": 10})</p>"},{"location":"api/backends/#or-mix-backends-for-different-components","title":"Or mix backends for different components","text":"<p>oq = OmniQ.from_backend(     backend=file_backend,  # For task queue     result_store_backend=sqlite_backend,  # For result storage     event_store_backend=pg_backend,  # For event storage     worker_type=\"async\",     worker_config={\"max_workers\": 20} )</p>"},{"location":"api/backends/#create-individual-components-from-backends","title":"Create individual components from backends","text":"<p>from omniq import TaskQueue, ResultStore, EventStore task_queue = TaskQueue.from_backend(file_backend, queues=[\"high\", \"medium\", \"low\"]) result_store = ResultStore.from_backend(sqlite_backend) event_store = EventStore.from_backend(pg_backend)</p>"},{"location":"api/events/","title":"Events","text":"<p>This section will cover the event system and how to use it for monitoring.</p> <p>The event system in OmniQ allows for tracking the lifecycle of tasks.</p> <p>Event Types: - <code>ENQUEUED</code> - <code>EXECUTING</code> - <code>COMPLETE</code> - <code>ERROR</code> - <code>RETRY</code> - <code>CANCELLED</code> - <code>EXPIRED</code> - <code>SCHEDULE_PAUSED</code> - <code>SCHEDULE_RESUMED</code></p> <p>Key Design Decisions: - Non-blocking event logging with disable option - Structured logging with metadata - Configurable event retention policies - Event logging automatically disabled when no event storage is configured - Store task events without serialization in SQLite, PostgreSQL, or as JSON files - Track task TTL events and schedule state changes - Clear separation between library logging and task event logging</p>"},{"location":"api/storage/","title":"Storage","text":"<p>This section will explain the storage options for task results and events.</p>"},{"location":"api/storage/#result-storage","title":"Result Storage","text":"<p>OmniQ can store the results of tasks in various backends:</p> <ul> <li>File Storage:</li> <li><code>omniq.results.file.FileResultStorage</code> (sync)</li> <li><code>omniq.results.file.AsyncFileResultStorage</code> (async)</li> <li>Memory Storage:</li> <li><code>omniq.results.memory.MemoryResultStorage</code> (sync)</li> <li><code>omniq.results.memory.AsyncMemoryResultStorage</code> (async)</li> <li>SQLite Storage:</li> <li><code>omniq.results.sqlite.SQLiteResultStorage</code> (sync)</li> <li><code>omniq.results.sqlite.AsyncSQLiteResultStorage</code> (async)</li> <li>PostgreSQL Storage:</li> <li><code>omniq.results.postgres.PostgresResultStorage</code> (sync)</li> <li><code>omniq.results.postgres.AsyncPostgresResultStorage</code> (async)</li> <li>Redis Storage:</li> <li><code>omniq.results.redis.RedisResultStorage</code> (sync)</li> <li><code>omniq.results.redis.AsyncRedisResultStorage</code> (async)</li> <li>NATS Storage:</li> <li><code>omniq.results.nats.NATSResultStorage</code> (sync)</li> <li><code>omniq.results.nats.AsyncNATSResultStorage</code> (async)</li> </ul>"},{"location":"api/storage/#event-storage","title":"Event Storage","text":"<p>Task lifecycle events can be stored for monitoring and debugging:</p> <ul> <li>SQLite Storage:</li> <li><code>omniq.events.sqlite.SQLiteEventStorage</code> (sync)</li> <li><code>omniq.events.sqlite.AsyncSQLiteEventStorage</code> (async)</li> <li>PostgreSQL Storage:</li> <li><code>omniq.events.postgres.PostgresEventStorage</code> (sync)</li> <li><code>omniq.events.postgres.AsyncPostgresEventStorage</code> (async)</li> <li>File Storage:</li> <li><code>omniq.events.file.FileEventStorage</code> (sync)</li> <li><code>omniq.events.file.AsyncFileEventStorage</code> (async)</li> </ul>"},{"location":"api/task_queues/","title":"Task Queues","text":"<p>This section will cover the different task queue implementations available in OmniQ.</p> <p>OmniQ supports multiple backends for task queues. Each backend has a sync and an async version.</p> <ul> <li>File Queue: Uses the local filesystem for storing tasks.</li> <li><code>omniq.queue.file.FileQueue</code> (sync)</li> <li><code>omniq.queue.file.AsyncFileQueue</code> (async)</li> <li>Memory Queue: Uses in-memory storage. This is not persistent.</li> <li><code>omniq.queue.memory.MemoryQueue</code> (sync)</li> <li><code>omniq.queue.memory.AsyncMemoryQueue</code> (async)</li> <li>SQLite Queue: Uses a SQLite database.</li> <li><code>omniq.queue.sqlite.SQLiteQueue</code> (sync)</li> <li><code>omniq.queue.sqlite.AsyncSQLiteQueue</code> (async)</li> <li>PostgreSQL Queue: Uses a PostgreSQL database.</li> <li><code>omniq.queue.postgres.PostgresQueue</code> (sync)</li> <li><code>omniq.queue.postgres.AsyncPostgresQueue</code> (async)</li> <li>Redis Queue: Uses a Redis server.</li> <li><code>omniq.queue.redis.RedisQueue</code> (sync)</li> <li><code>omniq.queue.redis.AsyncRedisQueue</code> (async)</li> <li>NATS Queue: Uses a NATS messaging server.</li> <li><code>omniq.queue.nats.NATSQueue</code> (sync)</li> <li><code>omniq.queue.nats.AsyncNATSQueue</code> (async)</li> </ul> <p>All task queue implementations support multiple named queues:</p> <ul> <li>File Queue: Directory structure for each queue</li> <li>SQLite/PostgreSQL Queue: Queue column approach with priority ordering</li> <li>Redis Queue: Queue prefixes</li> <li>NATS Queue: Subject prefixes</li> </ul>"},{"location":"api/workers/","title":"Workers","text":"<p>This section will describe the different worker types and their usage.</p> <p>OmniQ provides several worker types to execute tasks:</p> <ul> <li>Async Worker: Native async execution.</li> <li><code>omniq.workers.async.AsyncWorker</code></li> <li>Thread Worker: Thread pool execution.</li> <li><code>omniq.workers.thread.ThreadWorker</code></li> <li>Process Worker: Process pool execution.</li> <li><code>omniq.workers.process.ProcessWorker</code></li> <li>Gevent Worker: Gevent pool execution.</li> <li><code>omniq.workers.gevent.GeventWorker</code></li> </ul> <p>Key features of workers: - All worker types can handle both sync and async tasks. - Async workers run sync tasks in thread pools. - Thread/process workers run async tasks in event loops. - Workers can process tasks from multiple queues with priority ordering.</p>"}]}